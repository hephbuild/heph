package main

import (
	"capnproto.org/go/capnp/v3"
	"capnproto.org/go/capnp/v3/rpc"
	"context"
	"errors"
	"github.com/hephbuild/heph/internal/experiment/capnp/capnp"
	"io"
)

// ArithServer satisfies the Arith_Server interface that was generated
// by the capnp compiler.
type ArithServer struct{}

// Multiply is the concrete implementation of the Multiply method that was
// defined in the schema. Notice that the method signature matches that of
// the Arith_Server interface.
//
// The Arith_multiply struct was generated by the capnp compiler.  You will
// find it in arith.capnp.go
func (ArithServer) Multiply(ctx context.Context, call arith.Arith_multiply) error {
	res, err := call.AllocResults() // allocate the results struct
	if err != nil {
		return err
	}

	// Set the result to be the product of the two arguments, A and B,
	// that we received. These are found in the Arith_multiply struct.
	res.SetProduct(call.Args().A() * call.Args().B())
	return nil
}

// Divide is analogous to Multiply.  All capability server methods follow the
// same pattern.
func (ArithServer) Divide(ctx context.Context, call arith.Arith_divide) error {
	if call.Args().Denom() == 0 {
		return errors.New("divide by zero")
	}

	res, err := call.AllocResults()
	if err != nil {
		return err
	}

	res.SetQuo(call.Args().Num() / call.Args().Denom())
	res.SetRem(call.Args().Num() % call.Args().Denom())
	return nil
}

func Serve(ctx context.Context, rwc io.ReadWriteCloser) error {
	// Instantiate a local ArithServer.
	server := ArithServer{}

	// Derive a client capability that points to the server.  Note the
	// return type of arith.ServerToClient.  It is of type arith.Arith,
	// which is the client capability.  This capability is bound to the
	// server instance above; calling client methods will result in RPC
	// against the corresponding server method.
	//
	// The client can be shared over the network.
	client := arith.Arith_ServerToClient(server)

	// Expose the client over the network.  The 'rwc' parameter can be any
	// io.ReadWriteCloser.  In practice, it is almost always a net.Conn.
	//
	// Note the BootstrapClient option.  This tells the RPC connection to
	// immediately make the supplied client -- an arith.Arith, in our case
	// -- to the remote endpoint.  The capability that an rpc.Conn exports
	// by default is called the "bootstrap capability".
	conn := rpc.NewConn(rpc.NewStreamTransport(rwc), &rpc.Options{
		// The BootstrapClient is the RPC interface that will be made available
		// to the remote endpoint by default.  In this case, Arith.
		BootstrapClient: capnp.Client(client),
	})
	defer conn.Close()

	// Block until the connection terminates.
	select {
	case <-conn.Done():
		return nil
	case <-ctx.Done():
		return conn.Close()
	}
}
